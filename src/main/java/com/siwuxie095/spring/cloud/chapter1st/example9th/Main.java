package com.siwuxie095.spring.cloud.chapter1st.example9th;

/**
 * @author Jiajing Li
 * @date 2021-05-11 22:20:40
 */
public class Main {

    /**
     * 微服务不仅仅是编写代码
     *
     * 虽然构建个别微服务的概念很容易理解，运行和支持一个强大的微服务应用（特别是运行在云中的）涉及服务更多的编写代码。
     * 写一个强大的服务需要考虑几个因素。
     *
     * PS：微服务不仅仅是业务逻辑。你需要考虑服务将要运行的环境以及服务将如何扩展并具有弹性。
     *
     * 下面将详细讨论一下这些因素：
     * （1）合适的大小：你如何确保服务集中在一个责任领域？
     * 即 你如何确保你的微服务具有合适的大小，这样就不会让一个微服务承担太多的职责？记住，一个合适大小的服务可以让你
     * 快速更改应用程序并降低整个应用程序的整个中断的风险。
     *
     * （2）位置透明：如何管理物理位置，以便在不影响客户端服务的情况下添加和删除服务实例？
     * 即 在一个微服务应用，多个服务实例可以快速启动和关闭，你如何管理服务调用的物理细节？
     *
     * （3）有弹性的：当服务出现问题时，如何确保客户端服务 "快速失败"（fail fast）？
     * 即 你如何保护你的微服务消费者和路由失败的服务应用程序的完整性，并确保你有一种 "快速失败" 的方法？
     *
     * （4）可复用的：你如何确保每次启动新的服务实例时，它始终具有与现有实例相同的代码和配置？
     * 即 你如何确保生成的服务的每个新实例都具有与生产中所有其他服务实例相同的配置和基础代码？
     *
     * （5）可扩展的：你如何确保应用程序能够在服务之间的最小依赖关系下快速扩展？
     * 即 你如何使用异步处理和事件，最小化服务之间的直接依赖并确保你能优雅的扩展你的微服务？
     *
     * 这里以模式为基础的方法来回答这些问题。使用基于模式的方法，列出了可以在不同的技术实现中使用的通用设计。虽然这里
     * 选择使用 Spring Boot 和 Spring Cloud 来实现这些模式，但没有任何东西可以阻止你使用此处介绍的概念，并将其与
     * 其他技术平台一起使用。具体来说，包括以下六类微服务模式：
     * （1）核心开发模式
     * （2）路由模式
     * （3）客户端弹性模式
     * （4）安全模式
     * （5）日志记录和跟踪模式
     * （6）构建和部署模式
     *
     * 下面来更详细地介绍这些模式。
     *
     *
     *
     * 1、微服务核心开发模式
     *
     * 微服务核心开发模式是构建微服务最基础的部分。如下的过程将贯穿于基本的服务设计之中。
     * （1）服务粒度：服务具有什么正确层次的职责？
     * 即 你如何将业务领域分解成微服务以使每个微服务都具有正确层次的职责？服务粒度过粗，它的职责重叠到不同的业务问题
     * 域，使得服务随时间变化难以维护。服务粒度过细，它会增加应用程序的整体复杂性，并将服务变为 "哑" 数据抽象层，除
     * 了访问数据存储所需的逻辑以外，它没有逻辑。
     * （2）通信协议：客户端和服务端如何来回传输数据？
     * 即 开发者将如何与你的服务通信？你会使用 XML（可扩展标记语言）、 JSON（JavaScript 对象标记法），或一个二进
     * 制协议，如 Thrift 向你的微服务来回发送数据？这里将分析对于微服务为什么 JSON 是最理想的选择。同时，JSON 已
     * 经成为向微服务发送和接收数据最常见的选择。
     * （3）接口设计：你计划如何向客户端暴露你的服务端点？
     * 即 设计一个开发者计划用于调用你的服务真实接口的最好的方法是什么？你如何构造能够表达服务含义的 URLs？你的服务
     * 如何进行版本控制？一个好的微服务接口设计让你的服务更直观。
     * （4）配置管理：你的服务如何管理其特定于应用程序的配置，从而使代码和配置是独立的实体？
     * 即 你如何管理你的微服务配置使它迁移到不同的云环境，你永远不需要改发应用程序核心代码或配置。
     * （5）事件处理：如何使用事件在服务之间传递状态和更改数据？
     * 即 你如何让你的微服务使用事件以尽量减少微服务之间的硬编码依赖关系和增加应用的弹性。
     *
     * PS：当你正在设计微服务时，你必须考虑服务将如何被消费和它如何与外部通信。
     *
     *
     *
     * 2、微服务路由模式
     *
     * 微服务路由模式用来处理客户端应用程序。该客户端应用程序要消费一个被发现服务位置和被路由到该位置的微服务。在一
     * 个基于云的应用程序，你可能有数百个正在运行的微服务实例。你需要从这些物理 IP 地址抽离出来，且有一个单一的服务
     * 调用入口，使你可以始终为所有服务调用加强安全性和内容策略。
     *
     * 服务发现和路由回答这个问题，"你如何得到你的客户到一个指定服务实例的服务请求？"
     * （1）服务发现：你如何使你的微服务是可发现的，以使客户端应用程序可以发现它们而不必要将服务的位置硬编码到应用
     * 程序？你如何确保失常的微服务实例能够从可用服务实例池中移除？
     * （2）服务路由：你如何为你所有的服务提供一个单一的入口点，使安全策略和路由规则统一适用于多种服务和你微服务应用
     * 的服务实例？你如何确保团队中的每个开发人员不必拿出向他们的服务提供路由的解决方案？
     *
     * 服务发现和服务路由似乎在它们之间有一个硬编码的情况（首先是服务路由和服务发现）。然而，两种模式互不依赖。例如，
     * 可以实现服务发现而无需服务路由。也能实现服务路由而无需服务发现（虽然它的实现更加困难）。
     *
     * 服务发现和路由是任何大规模微服务应用的关键部分。
     * （1）服务路由给微服务客户端一个可访问的逻辑 URL，作为一个策略执行点，如授权、认证和内容检查。
     * （2）服务发现使客户端从服务的物理地址抽离出来。新的微服务实例可以按比例的增加，不健康的服务实例可以透明地从
     * 服务中删除。
     *
     *
     *
     * 3、微服务客户端弹性模式
     *
     * 因为微服务架构是高度分散的，你需要重视如何预防一个这样的问题：一个单一的服务（或服务实例）对服务消费者上下级联。
     * 为此，将认论四种客户端弹性模式：
     * （1）客户端负载均衡模式（Client-side load balancing）：你如何在客户端服务缓存你服务实例的位置，使客户端
     * 调用一个微服务的多个实例时能够被负载均衡到所有健康的微服务实例？
     * PS：客户端服务缓存从服务发现取回的微服务端点和确保服务调用实例之间的负载均衡。
     *
     * （2）断路器模式（Circuit breaker）：如何防止客户继续调用失败或遭遇性能问题的服务？当服务运行缓慢时，客户端
     * 调用它很消耗资源。你想失败的微服务调用能够快速失败，使调用客户端可以快速响应并采取适当的措施。
     * PS：断路器模式确保一个客户端服务不能重复调用失败的服务。相反，一个断路器能用 "快速失败" 来保护客户端。
     *
     * （3）回退模式（Fallback）：当服务调用失败时，你如何提供一个 "插件" 机制，允许服务客户端尝试通过调用其他微服
     * 务的方式来执行其工作？
     * PS：当客户端确实失败时，是否有另一种方式，客户端可以从中检索数据或采取措施？
     *
     * （4）舱壁模式（Bulkhead）：微服务应用使用多个分布式资源来完成他们的工作。如何隔离这些调用使一个异常服务调用
     * 不会对应用程序的其余部分产生负面影响？
     * PS：你如何隔离不同的客户端服务调用，使失败的服务不占用所有的客户端资源？
     *
     * 这些模式可以保护服务消费者免受异常服务的冲击。
     *
     * 对于微服务，你必须保护在异常服务中的服务调用者。记住，慢服务或宕机的服务会造成即时服务之外的中断。
     *
     *
     *
     * 4、微服务安全模式
     *
     * 如果不谈微服务安全，就不能完整的讨论微服务。这里将讨论三个基本的安全模式。它们是：
     * （1）认证：你如何确定调用服务的服务客户端是谁？
     * （2）授权：你如何确定服务客户端调用微服务是被允许的试图采取行动的行为？
     * （3）证书管理和传播：如何防止服务客户端经常地为事务中的服务调用提供凭据？具体来说，将看看如何基于令牌的安全标
     * 准，如：OAuth2 和 JavaScript Web Tokens（JWT） 可以用来获得一个令牌，它被从服务调用传递给服务调用来为用
     * 户提供认证和授权。
     *
     * 通过以上描述的三种模式可以建立一个认证服务，让它保护你的微服务。
     *
     * 例如，使用基于令牌的安全方案，可以在不传递客户凭证的情况下实现服务身份验证和授权。
     *
     *
     *
     * 5、微服务日志记录和跟踪模式
     *
     * 微服务的优势是将单体应用程序分解成小的，可以独立部署的一个功能块。微服架构的不足之处是，在你的应用程序和服务
     * 它更难调试和跟踪。
     *
     * 为此，来看看三个核心日志和跟踪模式：
     * （1）日志关联分析（Log correlation）：你是如何将单个用户事务服务之间所有产生的日志联系在一起的？用这种模
     * 式，将研究如何实现一个关联 ID，它是一个惟一标识符，它将在事务中的所有服务调用中进行传递，并可用于将来自每个
     * 服务的日志条目绑定在一起。
     * （2）日志聚合（Log aggregation）：这种模式将看看如何将你的微服务（和它们个别的实例）产生的日志推送到一个
     * 可查询的数据库。也将看到如何使用关联 ID 协助搜索你的聚合日志记录。
     * （3）微服务跟踪（Microservice tracing）：最后，将探讨如何使所有涉及服务调用的客户端流程可视化，并了解事
     * 务中涉及的服务性能特征。
     *
     * 成熟的日志记录和跟踪策略使跨多个服务的调试处理可管理。
     *
     *
     *
     * 6、微服务构建和部署模式
     *
     * 微服务架构核心部分之一是一个微服务的每个实例应该与它的其它所有实例是相同的。你不能允许 "配置漂移"（服务器部
     * 署后发生的某些更改），因为这可以在你的应用程序引入不稳定性。
     *
     * PS：一旦部署了服务，其运行的基础设施就不再被人类的双手所触及。一个不可变的基础设施是利用微服架构成功的关键
     * 部分，因为你必须保证你在生产中对一个特定的微服务启动的每个微服务实例，它都和其兄弟实例是相同的。
     *
     * 为此，这里的目标是整合你的基础设施的配置到你部署构建的过程，使你不再向一个已经运行的基础设施部署软件构件，
     * 如：Java WAR 或 EAR 包。相反，你要建立和编译你的微服务和虚拟机镜像，这将作为构建过程的一部分。然后，当
     * 你的微服务被部署后，整个在服务器上运行的虚拟机镜像也被部署。
     *
     * 这里也将看到如何改变你的构建和部署管道使你的微服务和服务器作为一个工作单元运行它们的部署。
     *
     * 这里将介绍以下模式和主题：
     * （1）构建和部署管道：你如何创建一个可重复的构建和部署的过程，突出一键生成和部署到你的组织任何环境中？
     * PS：持续集成/持续交付的管道如下：（a）代码编译（b）运行单元和集成测试（c）创建运行时构件（d）制作虚拟机镜
     * 像（e）提交镜像到仓库
     *
     * （2）基础设施即代码：你如何看待将服务配置为可以在源代码管理下执行和管理的代码？
     * PS：开发者为微服务构建代码并运行测试。然而，开发者也把基础设施当做代码对待。当微服务被编译和打包，就立即制
     * 作和设置虚拟服务器或已安装上微服务的容器镜像。
     *
     * （3）不可变的服务器：一旦微服务镜像被创建，你如何保证它从未在部署后改变？
     * PS：当一个镜像被制作和部署时，开发者和系统管理员都不允许对服务器进行修改。在环境间进行升级时，整个容器或镜
     * 像都是使用服务器第一次启动时传递到服务器的特定于环境的变量启动的。
     *
     * （4）凤凰服务器：服务器运行时间越长，配置漂移的机会越多。你如何确保运行微服务的服务器定期卸载和重建不可变的
     * 镜像？
     * PS：因为真实的服务器经常被作为持续集成过程的一部分被卸载，新服务器正在启动就被卸载。这大大降低了配置漂移之
     * 间的环境变化。
     *
     * 这里使用这些模式和主题的目标是，在影响到你的上层环境（如阶段 stage 或生产 production）之前，尽可能快地
     * 暴露和消灭配置漂移。
     *
     * 你想要的微服务部署和它运行的服务器是极小的构件，它们作为一个整体被部署。
     *
     * 一切都开始于一个开发人员将他们的代码提交到源代码管理库。这是开始构建/部署过程的触发器。
     */
    public static void main(String[] args) {

    }

}
