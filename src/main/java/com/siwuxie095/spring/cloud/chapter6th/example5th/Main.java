package com.siwuxie095.spring.cloud.chapter6th.example5th;

/**
 * @author Jiajing Li
 * @date 2021-06-11 21:51:48
 */
public class Main {

    /**
     * Zuul 过滤器
     *
     * 同时能够代理所有请求通过 Zuul 网关允许你简化你的服务调用，当你想写可以应用于流经网关的所有的服务调用的
     * 定制逻辑，Zuul 的真正优势就体现出来了。通常，这种定制逻辑用于强制一致的应用程序策略集，如：安全、日志
     * 记录和服务跟踪。
     *
     * 这些应用程序策略被认为是横切关注点，因为你希望将它们应用到应用程序中的所有服务，而不必修改每个服务来实现
     * 它们。在这种方式中，Zuul 过滤器可以使用同样的方式作为一个 J2EE Servlet 过滤器或 Spring 切面，它可以
     * 拦截一个广泛的行为和装饰或修改调用行为而没有原始编码器知道该变化。当一个 Servlet 过滤器或 Spring 切面
     * 被定位到一个特定的服务，使用 Zuul 和 Zuul 过滤器允许你实现通过 Zuul 路由的所有服务的横切关注点。
     *
     * Zuul 允许你在 Zuul 网关使用过滤器创建自定义的逻辑。过滤器允许你实现每个服务请求在实现时通过的业务逻辑
     * 链。Zuul 支持三种类型的过滤器：
     * （1）前置过滤器：在 Zuul，实际请求到达目标发生之前，前置过滤器被调用。前置过滤器通常执行确保服务有一个
     * 一致的消息格式的任务（例如，HTTP 头部的 key 已就位）或作为一个看门人确保用户调用服务已认证（他们说他们
     * 是谁）和授权（他们可以做他们请求要做的）。
     * （2）后置过滤器：在调用目标服务之后，调用一个后置过滤器，并将响应发送回客户端。通常会实现一个后置过滤器，
     * 将从目标服务返回的响应记录下来，处理错误，或者对响应的敏感信息进行审核。
     * （3）路由过滤器：路由过滤器被用于在调用目标服务之前拦截该调用。通常使用路由过滤器来确定是否需要进行某种
     * 级别的动态路由。例如，你使用路由级过滤器，它将在同一服务的两个不同版本之间进行路由，以便将一小部分对服务
     * 的调用路由到一个新版本的服务，而不是现有的服务。这将允许你将新功能暴露给少量用户，而不必让每个人都使用新
     * 服务。
     *
     * 前置、路由和后置过滤器形成一个客户端请求流通过的管道。作为一个请求进入 Zuul，这些过滤器可以处理传入的
     * 请求。
     *
     * 在处理服务客户端的请求时，前置、后置和路由过滤器是这样组合在一起的，流程如下：
     * （1）当传入的请求进入 Zuul，前置过滤器被执行。
     * （2）路由过滤器允许你覆盖 Zuul 的默认路由逻辑和将用户路由到他们需要去的地方。
     * （3）一个路由过滤器可以在 Zuul 动态路由服务。
     * （4）最后，Zuul 将确定目标路由并发送请求到目标。
     * （5）在目标服务被调用之后，返回响应将回流通过任何 Zuul 后置过滤器。
     *
     * 如果你遵循上面的流程，你将看到一切都始于服务客户端通过服务网关暴露的服务发出的调用。在那里进行下列活动：
     * （1）任何定以在 Zuul 网关的前置过滤器通过 Zuul 作为请求进入 Zuul 网关被调用。前置过滤器可以在到达实
     * 际服务之前检查和修改 HTTP 请求。前置过滤器不能将用户重定向到不同的端点或服务。
     * （2）前置过滤器通过 Zuul 传入的请求被执行之后，Zuul 将执行任何定义的路由过滤器。路由过滤器可以更改服
     * 务所在的目的地。
     * （3）如果一个路由过滤想重定向服务调用到另外的地方，那里是 Zuul 服务器被配置为发送路由的地方，它可以这
     * 样做。然而，一个 Zuul 路由过滤器不做 HTTP 重定向，而是终止传入的 HTTP 请求，然后调用代表原始调用者
     * 的路由。这意味着路由过滤器必须完全拥有动态路由的调用，不能执行 HTTP 重定向。
     * （4）如果路由过滤器不动态重定向调用者对一个新的路由，Zuul 服务器将发送路由到原来的目标服务。
     * （5）目标服务被调用后，Zuul 后置过滤器将被调用。后置过滤器可以检查和修改从调用的服务返回的响应。
     *
     * 了解如何实现 Zuul 过滤器的最好方式是在使用中领会。为此，后续你将构建一个前置、路由和后置过滤器，然后
     * 通过它们运行服务客户端请求。
     *
     * 在处理你的 EagleEye 服务的请求时，是这样将这些过滤器组合在一起的，流程如下：
     * （1）TrackingFilter（跟踪过滤器）将检查每个传入的请求，若在 HTTP 头不存在关联 ID，则创建一个关联 ID。
     * （2）SpecialRoutesFilter（特定的路由过滤器）将决定是否要将一定数量的路由发送到不同的服务（新旧版本的
     * 目标服务）。
     * （3）ResponseFilter（响应过滤器）将确保从 Zuul 返回的每个响应在 HTTP 头已经包含关联 ID。
     *
     * 总之，Zuul 过滤器提供集中的服务调用跟踪、日志记录和动态路由。Zuul 过滤器允许你在微服务调用之前执行自定
     * 义的规则和策略。
     *
     * 三个过滤器具体如下：
     * （1）TrackingFilter：TrackingFilter 将是一个前置过滤器，它确保从 Zuul 流入的每个请求都有一个与它相
     * 关的关联 ID。关联 ID 是一个唯一的 ID，它在所有当执行一个客户请求时被执行的微服务间传输。关联 ID 允许你
     * 跟踪事件链，该事件链出现在一个调用通过一系列的微服务调用时。
     * （2）SpecialRoutesFilter：SpecialRoutesFilter 是一个 Zuul 路由过滤器，它将检查传入的路由并确定你
     * 是否想在路由上进行 A/B 测试。A/B 测试是一种技术，其中一个用户（在这种情况下是一个服务）随机地使用同一服
     * 务提供两种不同版本的服务。A/B 测试背后的想法是，在将新功能发布到整个用户群体之前，可以对其进行测试。在这
     * 里的示例中，你将拥有同一组织服务的两个不同版本。少数用户将被路由到较新版本的服务，而大多数用户将被路由到
     * 旧版本的服务。
     * （3）ResponseFilter：ResponseFilter 是一个后置过滤器，它将与服务调用相关的关联 ID 注入到发送给客户
     * 端的 HTTP 响应头中。通过这种方式，客户端将访问与它们请求相关的关联 ID。
     */
    public static void main(String[] args) {

    }

}
