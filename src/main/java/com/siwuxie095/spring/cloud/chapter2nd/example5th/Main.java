package com.siwuxie095.spring.cloud.chapter2nd.example5th;

/**
 * @author Jiajing Li
 * @date 2021-05-21 22:00:00
 */
public class Main {

    /**
     * 运维：严格的运行时构建
     *
     * 对于 DevOps 工程师，微服务设计就是所有关于投产后服务的管理。编写代码通常是容易的部分。保持它
     * 的运行是最困难的部分。
     *
     * 而 DevOps 是一个丰富多彩的和新兴的 IT 领域，你将使用四项原则开始你的微服务开发工作。这些原则
     * 是：
     * （1）微服务应该是独立和单独可部署的，多个服务实例作为单独的软件构件启动和停止。
     * （2）微服务是可配置的。当服务实例启动时，它应该从中心位置读取它需要用来配置自己的数据，或者将
     * 其配置信息传递为环境变量。配置服务不需要人为干预。
     * （3）微服务实例需要对客户端是透明的。客户端永进不应该知道服务的确切位置。相反，一个微服务客户
     * 端应该与服务发现代理交互，将允许应用程序找到一个微服务实例，而无需知道它的物理位置。
     * （4）微服务应该显示其健康状况。这是云架构的关键部分。微服务实例失败，客户端需要路由绕开坏的服
     * 务实例。
     *
     * 这四个原则揭示了矛盾与微服务开发共存。微服务规模和范围较小，但它们的使用在一个应用中引入了更多
     * 的活动部件，特别是因为微服务是分布式的，并且在自己的分布式容器彼此独立运行。这将为应用程序中的
     * 故障点提供高度的协调和更多的机会。
     *
     * 从一个 DevOps 的视角，你必须解决一个微服务预先的业务需求，将这四个原则转变为一套标准的生命周
     * 期事件（每次微服务发生构建和部署到一个环境）。这四条原则可以映射到以下操作生命周期步骤：
     * （1）服务装配：你如何打包和部署服务以保证可复用和一致性，以便以同样的方式部署相同的服务代码和
     * 运行时。
     * （2）服务引导：你如何将特定于应用程序和环境的配置代码与运行时代码分开，这样你就可以开始在任何
     * 环境中快速部署微服务实例而不需要人为干预来配置微服务。
     * （3）服务注册/发现：当一个新的微服务实例被部署，如何使新的服务实例被其他应用程序的客户端发现。
     * （4）服务监控：在微服务环境是极为常见的，由于高可用性需求而运行相同服务的多个实例。从一个
     * DevOps 的角度来看，你需要监控微服务实例和保证微服务任何故障被绕过，境况不佳的服务实例都被取
     * 下。
     *
     *
     * PS：构建微服务服务应用的十二要素
     *
     * 这里最大的一个希望是，你能意识到一个成功的微服务架构需要强大的应用开发和 DevOps 的实践。这一
     * 做法的最简洁的总结可以在 Heroku 的十二要素应用宣言（https://12factor.net/）发现。这个文档
     * 提供了 12 个最佳实践，在构建微服务的时候，你应该始终谨记在脑海里。这里总结如下：
     * （1）基准代码：所有应用程序代码和服务器配置信息都应处于版本控制中。每个微服务在源码控制系统内
     * 有自己独立的代码库。
     * （2）依赖：通过使用构建工具如 Maven（Java）显式声明你的应用程序的依赖。第三方 JAR 依赖性应
     * 该使用其特定版本号声明。这允许你的微服务总是使用相同版本的 lib 库进行构建。
     * （3）配置：独立于代码存储应用程序配置（特别是特定于环境的配置）。你的应用程序配置不应该与源代
     * 码在同一个存储库中。
     * （4）后端服务:你的微服务往往会通过网络与一个数据库或消息系统进行通信。当它这样做时，你应该确
     * 保在任何时候，你都可以将数据库的实现从内部管理的服务转换为第三方服务。比如，把你的服务从本地
     * 管理的 Postgres 数据库改变成由亚马逊管理的。
     * （5）构建、发布、运行：将你的构建、发布和运行部署的应用程序各部分完全分离。一旦代码被构建，开
     * 发人员就永远不应该在运行时对代码进行更改。任何修改都需要重新执行构建过程和重新部署。构建的服务
     * 是不可变的，不能更改。
     * （6）进程：你的微服务应该是无状态的。它们在任何时候都可以被杀死和取代，而不必害怕一个受损的服
     * 务实例将导致数据丢失。
     * （7）端口绑定：一个微服务对服务的运行时引擎（打包在服务的可执行文件）是完全独立的。你将能运行
     * 该服务而不需要单独的 Web 或应用服务器。服务应该在命令行中独立启动，并能立即通过暴露的 HTTP
     * 端口被访问。
     * （8）并发：当你需要进行伸缩时，不要依赖于单个服务中的线程模型。相反，加载更多的微服务实例和在
     * 水平方向扩展。这并不排除在你的微服务使用线程，但别指望把它作为你伸缩的唯一途径。规模扩大，而
     * 不是上升。
     * （9）通用性：微服务是一次性的，一经要求就可以启动和停止。启动时间应尽量减少，当接收到操作系统
     * 的一个终止信号时，进程应该优雅地关闭。
     * （10）开发环境与线上环境等价：最小化服务运行的所有环境之间的差距（包括开发人员的桌面）。开发
     * 人员应该在本地使用与实际服务将运行的相同的基础设施来进行服务开发。它还意味着服务在环境之间部
     * 署的时间应该是几个小时，而不是几个星期。一旦代码被提交，它应该已经被测试和从开发一直到生产尽
     * 快升级。
     * （11）日志：日志是一个事件流。一旦日志被输出，它们对工具将是可流化的，如 Splunk 或 Fluentd，
     * 它们将聚合日志，并将其写入到中心存储设备。微服务不应该关心这项技术是如何出现的，开发人员应该在
     * 视觉上通过 STDOUT 看日志，当日志正在被输出的时候。
     * （Splunk：https://www.splunk.com/，Fluentd：https://www.fluentd.org/）
     * （12）管理进程：开发人员常常不得不针对他们的服务（数据迁移或转换）执行管理任务。这些任务不应该
     * 是临时的，而应该通过源代码存储库管理和维护的脚本来完成。这些脚本应该是可重复的，并且在它们运行
     * 的每个环境中都不改变（在每个环境中都不修改脚本代码）。
     *
     *
     *
     * 1、服务装配：打包和部署微服务
     *
     * 从一个 DevOps 角度，微服务架构背后的关键概念是，一个微服务多实例可以被快速部署以响应应用环境
     * 的变化（例如，用户请求的突然涌入、基础设施中的问题等）。
     *
     * 要做到这一点，一个微服务需要作为一个单独的构件与它定义的所有的依赖被打包和安装。这个构件可以被
     * 部署到任意一台已安装 Java JDK 的服务器上。这些依赖关系，还包括将运行微服务的运行时引擎（例如，
     * HTTP 服务器或应用程序容器）。
     *
     * 这个持续构建、打包和部署的过程是服务装配。在服务装配步骤中，源代码在它的运行时引擎环境下被编译
     * 并打包。其中一些细节如下：
     * （1）构建/部署引擎将使用 Spring Boot 的 Maven 脚本来启动和构建。
     * （2）当开发人员提交代码时，构建/部署引擎构建并打包代码。
     * （3）构建的输出是一个单独的可执行 JAR，其中嵌入了应用程序和运行时容器。
     *
     * 幸运的是，几乎所有的 Java 微服务框架将包括一个运行时引擎，它可以打包和部署代码。例如，你可以
     * 使用 Maven 和 Spring Boot 构建一个可执行的 Java jar 文件，它有一个嵌入式 Tomcat 引擎内
     * 置到 JAR 里。在下面的命令行示例中，你将许可服务构建为可执行 JAR，然后从命令行启动 JAR 文件：
     *
     * mvn clean package && java –jar target/licensing-service-0.0.1-SNAPSHOT.jar
     *
     * 对于某些运维团队，在 JAR 文件中嵌入运行时环境的概念是他们考虑部署应用程序的方式的重大转变。在
     * 传统 J2EE 企业组织中，应用程序部署到应用服务器。这个模型意味着应用服务器本身就是一个实体，通
     * 常由一个系统管理员来管理，这些系统管理员独立于其部署的应用程序之外，管理服务器的配置。
     *
     * 应用程序服务器配置与应用程序的分离引入了部署过程中的故障点，因为在许多组织中，应用服务器的配置
     * 并不保留在源代码控制之下，而是通过用户界面和自己编写的管理脚本的组合来管理的。配置漂移很容易潜
     * 入应用服务器环境，并突然导致表面上出现的随机中断。
     *
     * 使用嵌入在构件中的运行时引擎的单个可部署构件消除了许多配置漂移的机会。它还允许你将整个构件放在
     * 源代码控制之下，并允许应用程序团队通过如何构建和部署应用程序来更好地解释原因。
     *
     *
     *
     * 2、服务引导：管理微服务的配置
     *
     * 服务引导在微服务第一次启动并需要加载应用程序的配置信息时发生。
     *
     * 正如任何应用程序开发人员都知道的那样，有时需要使应用程序的运行时行为可配置。通常这涉及从应用程
     * 序部署的属性文件中读取应用程序配置数据，或者从数据存储（如关系数据库）中读取数据。
     *
     * 当服务启动（引导），它从中央存储库读取配置。其中一些细节如下：
     * （1）如果服务的配置发生变化，则应销毁正在运行得服务的旧配置或通知重新读取它们的配置信息。
     * （2）理想情况下，配置存储应该能够对所有配置更改进行版本化，并提供对上次更改配置数据的审核跟踪。
     * （3）当一个微服务启动，任何环境的具体信息或应用程序的配置数据信息应该：
     *      a）作为环境变量传递到启动服务
     *      b）从中央配置管理库中读取
     *
     * 微服务经常遇到同一类型的配置要求。不同的是，微服务应用运行在云中，你可能有数百甚至数千个正在运
     * 行的服务实例。更复杂的是，这些服务可能会遍布全球。大量的地理位置分散的服务，这将使使用新的配置
     * 数据重复部署你的服务变得难以实施。
     *
     * 将数据存储在服务的外部数据存储中解决了这一问题，但为云端微服务提供了一堆独特的挑战：
     * （1）配置数据往往结构简单，通常是经常读和很少写的。在这种情况下，关系型数据库被过度使用，因为
     * 它们是被设计来管理更为复杂的数据模型，而不仅仅是一个简单的键值对集合。
     * （2）因为数据是被有规律的访问的，但很少变化，所以数据必须具有低延迟的可读性。
     * （3）数据存储必须高度可用，并且与读取数据的服务关系密切。配置数据存储不能完全关闭，因为它将成
     * 为应用程序的单一故障点。
     *
     * 后续将展示如何使用像一个简单的 key-value 数据存储管理你的微服务应用程序配置数据。
     *
     *
     *
     * 3、服务注册与发现：客户端如何与微服务通信
     *
     * 从微服务消费者的角度，微服务应该是位置透明的，因为在基于云的环境，服务器是短暂的。短时间意味着
     * 服务器承载的服务通常比在企业数据中心运行的服务寿命更短。基于云的服务器可以很快地启动和卸载，并
     * 使用一个全新的 IP 地址分配给正在运行的服务器。
     *
     * 坚持将服务器视为短暂的一次性对象，微服务架构通过一个服务运行多个实例，可以实现高度的可扩展性和
     * 可用性。服务需求和弹性可以在情况允许的情况下迅速得到管理。每个服务都有一个唯一的和永久的 IP
     * 地址分配给它。临时服务器的缺点是，随着服务器的不断增加，人为或手工管理大量的临时服务器池将导致
     * 中断缺陷。
     *
     * 一个微服务实例需要在第三方代理注册本身。这个注册过程称为服务发现。
     *
     * 服务发现代理抽象出服务的物理位置。其中一些细节如下：
     * （1）当服务实例启动时，它将向服务发现代理注册自身。
     * （2）服务客户端永远不知道服务实例所在的物理位置。相反，它向服务发现代理询问一个健康服务实例的
     * 位置。
     *
     * 当一个微服务实例在服务发现代理注册，它将告诉发现代理的两件事：
     * 该服务实例的物理 IP 地址或域名地址，和一个逻辑名称，即应用程序可以使用它查找服务。某些服务发现
     * 代理还需要一个 URL 返回到注册服务，服务发现代理可以使用它来执行健康检查。
     *
     * 然后，服务客户端与发现代理进行通信，查找服务的位置。
     *
     *
     *
     * 4、监控微服务健康状况
     *
     * 服务发现代理不只是充当一个将客户端引导到服务位置的流量管理器。在一个基于云的微服务应用，你通常
     * 有一个服务运行多个实例的情况。迟早有一天，其中的一个服务实例会失败。服务发现代理监视注册的每个
     * 服务实例的健康情况，并从路由表中删除任意服务实例，以确保客户端不向已失败的服务实例发送请求。
     *
     * 微服务恢复以后，服务发现代理将继续监控和 ping 健康检查接口来确保服务可用。
     *
     * 通过构建一个一致的健康检查接口，你可以使用基于云的监控工具来发现问题并对其作出适当的响应。
     *
     * 服务发现代理使用暴露的健康状况 URL 来检查微服务的健康状况。其中一些细节如下：
     * （1）服务发现代理监视服务实例的健康情况。如果实例失败，健康检查将从可用实例池中删除它。
     * （2）大多数服务实例将暴露一个将由服务发现代理调用的健康检查 URL。如果调用返回一个 HTTP 错误
     * 或没有及时响应，则服务发现代理可以关闭该实例或不将请求路由到它。
     *
     * 如果服务发现代理发现了服务实例的问题，它可以采取纠正措施，例如关闭有问题的实例或启动额外的服务
     * 实例。
     *
     * 在一个使用 REST 的微服务环境，创建一个健康检查接口最简单的方法是暴露一个 HTTP 端点，它可以返
     * 回一个 JSON 有效负载和 HTTP 状态代码。在一个没有基于 Spring Boot 的微服务，编写一个返回服
     * 务健康状况的端点，这通常是开发人员的责任。
     *
     * 在 Spring Boot，暴露一个端点是微不足道的，只不过是修改你的 Maven 构建文件，使其包括 Spring
     * Actuator 模块。Spring Actuator 提供开箱即用的操作端点，这将帮助你了解和管理服务的健康状况。
     * 为了使用 Spring Actuator，你需要确保在你的 Maven 构建文件中包括以下依赖：
     *
     * <dependency>
     *     <groupId>org.springframework.boot</groupId>
     *     <artifactId>spring-boot-starter-actuator</artifactId>
     * </dependency>
     *
     * PS：每个服务实例的健康检查允许监视工具确定服务实例是否正在运行。"开箱即用" 的 Spring Boot
     * 健康检查将返回服务是否已启动以及一些基本信息，如服务器上留下了多少磁盘空间。
     *
     * 如果你访问了在许可服务上的 http://localhost:8080/health 端点，你应该看到返回的健康数据。
     * 如下：
     *
     * {
     *     "status":"UP",
     *     "diskSpace":{
     *         "status":"UP",
     *         "total":499963174912,
     *         "free":340398813184,
     *         "threshold":10485760
     *     }
     * }
     *
     * 健康检查可能不仅仅是一个启动和停止的指标。它还可以提供有关正在运行微服务实例的服务器状态。这使
     * 得监控体验更加丰富。
     */
    public static void main(String[] args) {

    }

}
