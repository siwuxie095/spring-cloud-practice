package com.siwuxie095.spring.cloud.chapter5th.example2nd;

/**
 * @author Jiajing Li
 * @date 2021-06-01 08:14:59
 */
public class Main {

    /**
     * 什么是客户端弹性模式
     *
     * 客户端弹性软件模式的重点是，在远程服务发生错误或表现不佳时保护远程资源（另一个微服务调用或数据库查询）的客户端
     * 免于崩溃。这些模式的目标是让客户端 "快速失败"，而不消耗诸如数据库连接和线程池之类的宝贵资源，并且可以防止远程
     * 服务的问题向客户端的消费者进行 "上游" 传播。
     *
     * 有四种客户端弹性模式，它们分别是：
     * （1）客户端负载均衡（client load balance）模式；
     * （2）断路器（circuit breaker）模式；
     * （3）后备（fallback）模式；
     * （4）舱壁（bulkhead）模式。
     *
     * 如下展示了如何将这些模式用于微服务消费者和微服务之间：
     * （1）客户端负载均衡模式：服务客户端缓存在服务发现期间检索到的微服务端点。
     * （2）断路器模式：断路器模式确保服务客户端不会重复调用失败的服务。
     * （3）后备模式：当调用失败时，后备模式询问是否有可执行的替代方案。
     * （4）舱壁模式：舱壁模式隔离服务客户端上不同的服务调用，以确保表现不佳的服务不会耗尽客户端的所有资源。
     *
     * PS：这四个客户端弹性模式充当服务消费者和服务之间的保护缓冲区。
     *
     * 这些模式是在调用远程资源的客户端中实现的，它们的实现在逻辑上位于消费远程资源的客户端和资源本身之间。
     *
     *
     *
     * 1、客户端负载均衡模式
     *
     * 在讨论服务发现时，之前就已经介绍了客户端负载均衡模式。客户端负载均衡涉及让客户端从服务发现代理（如 Netflix
     * Eureka）查找服务的所有实例，然后缓存服务实例的物理位置。每当服务消费者需要调用该服务实例时，客户端负载均衡
     * 器将从它维护的服务位置池返回一个位置。
     *
     * 因为客户端负载均衡器位于服务客户端和服务消费者之间，所以负载均衡器可以检测服务实例是否抛出错误或表现不佳。如
     * 果客户端负载均衡器检测到问题，它可以从可用服务位置池中移除该服务实例，并防止将来的服务调用访问该服务实例。
     *
     * 这正是 Netflix 的 Ribbon 库提供的开箱即用的功能，而不需要额外的配置。因为之前介绍了 Netflix Ribbon 的
     * 客户端负载均衡，所以这里就不再赘述了。
     *
     *
     *
     * 2、断路器模式
     *
     * 断路器模式是模仿电路断路器的客户端弹性模式。在电气系统中，断路器将检测是否有过多电流流过电线。如果断路器检测到
     * 问题，它将断开与电气系统的其余部分的连接，并保护下游部件不被烧毁。
     *
     * 有了软件断路器，当远程服务被调用时，断路器将监视这个调用。如果调用时间太长，断路器将会介入并中断调用。此外，断
     * 路器将监视所有对远程资源的调用，如果对某一个远程资源的调用失败次数足够多，那么断路器实现就会出现并采取快速失败，
     * 阻止将来调用失败的远程资源。
     *
     *
     *
     * 3、后备模式
     *
     * 有了后备模式，当远程服务调用失败时，服务消费者将执行替代代码路径，并尝试通过其他方式执行操作，而不是生成一个异
     * 常。这通常涉及从另一数据源查找数据或将用户的请求进行排队以供将来处理。用户的调用结果不会显示为提示问题的异常，
     * 但用户可能会被告知，他们的请求要在晚些时候被满足。
     *
     * 例如，假设有一个电子商务网站，它可以监控用户的行为，并尝试向用户推荐其他可以购买的产品。通常来说，可以调用微服
     * 务来对用户过去的行为进行分析，并返回针对特定用户的推荐列表。但是，如果这个偏好服务失败，那么后备策略可能是检索
     * 一个更通用的偏好列表，该列表基于所有用户的购买记录分析得出，并且更为普遍。这些更通用的偏好列表数据可能来自完全
     * 不同的服务和数据源。
     *
     *
     *
     * 4、舱壁模式
     *
     * 舱壁模式是建立在造船的概念基础上的。采用舱壁设计，一艘船被划分为完全隔离和防水的隔间，这称为舱壁。即使船的船体
     * 被击穿，由于船被划分为水密舱（舱壁），舱壁会将水限制在被击穿的船的区域内，防止整艘船灌满水并沉没。
     *
     * 同样的概念可以应用于必须与多个远程资源交互的服务。通过使用舱壁模式，可以把远程资源的调用分到线程池中，并降低一
     * 个缓慢的远程资源调用拖垮整个应用程序的风险。线程池充当服务的 "舱壁"。每个远程资源都是隔离的，并分配给线程池。
     * 如果一个服务响应缓慢，那么这种服务调用的线程池就会饱和并停止处理请求，而对其他服务的服务调用则不会变得饱和，因
     * 为它们被分配给了其他线程池。
     */
    public static void main(String[] args) {

    }

}
