package com.siwuxie095.spring.cloud.extend2nd.example5th;

/**
 * @author Jiajing Li
 * @date 2021-06-27 14:48:10
 */
public class Main {

    /**
     * 隐式授权
     *
     * 授权码模式可以在通过传统的服务器端 Web 编程环境（如 Java 或 .NET）运行 Web 应用程序时使用。如果
     * 客户端应用程序是纯 JavaScript 应用程序或完全在 Web 浏览器中运行的移动应用程序，并且不依靠服务器
     * 端调用来调用第三方服务，那么会发生什么呢？
     *
     * 这就是最后一种授权类型，即隐式授权，能够发挥作用的地方。
     *
     * 隐式授权通常用于处理完全在浏览器内运行的纯 JavaScript 应用程序。在其他授权流程中，客户端与执行用
     * 户请求的应用程序服务器进行通信，然后应用程序服务器与下游服务进行交互。使用隐式授权类型，所有的服务
     * 交互都直接从用户的客户端（通常是 Web 浏览器）发生。如下展示了在隐式授权中发生的一般流程。
     *
     * （1）JavaScript 应用程序的所有者已经通过 EagleEye OAuth2 服务器注册了应用程序。他们提供了一个
     * 应用程序名称以及一个回调 URL，该 URL 将被重定向并带有用户的 OAuth2 访问令牌。
     *
     * （2）JavaScript 应用程序将调用 OAuth2 服务。JavaScript 应用程序必须出示预注册的应用程序名称。
     * OAuth2 服务器将强制用户进行验证。
     *
     * （3）如果用户成功进行了验证，那么 EagleEye OAuth2 服务将不会返回一个令牌，而是将用户重定向回一
     * 个页面，该页面是 JavaScript 应用程序所有者在第一步中注册的页面。在重定向回的 URL 中，OAuth2
     * 访问令牌将被 OAuth2 验证服务作为查询参数传递。
     *
     * （4）应用程序将接收传入的请求并运行 JavaScript 脚本，该脚本将解析 OAuth2 访问令牌并将其存储
     * （通常作为 Cookie）。
     *
     * （5）每次调用受保护资源时，就会将 OAuth2 访问令牌出示给调用服务。
     *
     * （6）调用服务将确认 OAuth2 令牌，并检查用户是否被授权执行他们正在尝试的活动。
     *
     * 关于 OAuth2 隐式授权，记住下面几点。
     * （1）隐式授权是唯一一种 OAuth2 访问令牌直接暴露给公共客户端（Web 浏览器）的授权类型。在授权码授权
     * 中，客户端应用程序获得一个返回到托管应用程序的应用程序服务器的授权码。通过授权码授权，用户可以通过
     * 出示授权码来获得 OAuth2 访问权限。返回的 OAuth2 令牌不会直接暴露给用户的浏览器。在客户端凭据授权
     * 中，授权发生在两个基于服务器的应用程序之间。在密码授权中，向服务发出请求的应用程序和这个服务都是可
     * 信的，并且属于同一个组织。
     * （2）由隐式授权生成的 OAuth2 令牌更容易受到攻击和滥用，因为令牌可供浏览器使用。在浏览器中运行的任
     * 何恶意 JavaScript 都可以访问 OAuth2 访问令牌，并以他人的名义调用他人为了调用服务而检索到的 OAuth2
     * 令牌，实质上是在模拟他人。
     * （3）隐式授权类型的 OAuth2 令牌应该是短暂的（1～2 小时）。因为 OAuth2 访问令牌存储在浏览器中，
     * 所以 OAuth2 规范（和 Spring Cloud Security）不支持可以自动更新令牌的刷新令牌的概念。
     */
    public static void main(String[] args) {

    }

}
